# Strategy (策略模式)


# 我第一个真正引用到实际的生产项目当中的一种设计模式


# 简介
现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，过年回家可以坐飞机、坐火车、坐汽车等
每一种方式都可以称作一种策略，且这三种策略可以任意选择，互相替换


# 定义
该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户


# 优缺点
策略模式的主要优点如下
多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
策略模式可以提供相同行为的不同实现，客户可以根据不同需求选择不同的实现。
策略模式提供了对开闭原则的完美支持，对增加代码开放、对修改代码关闭。

其主要缺点如下 (个人感觉还好)
客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
策略模式造成很多的策略类。


# 应用 (个人理解)
主要是为了解决可替换的多条件语句的硬编码
举个栗子：
    if(a){                  switch(type){
        xxx                     case a:
    }else if(b){                     xxx
        xxx                     break;
    }else if(c){                 case b:
        xxx                         xxx
    }                           break;
    ......                  ......
其中xxx就是具体的可以互相替换的策略，只是由于参数的不同，会选择不同的策略
同理：我有钱就坐飞机、没钱就做火车


# 组成
service接口
serviceImpl实现 (一般为多种策略...)
context (上下文：消费者和接口之间通信、以及成员变量等)


# 具体代码，请查看Strategy目录


# 思考？
为什么在策略模式中，需要有上下文context的存在呢？
因为在策略模式中，消费者需要有一些属性或者方法，和接口做交互，
这样的交互，破坏了类的封装性，同时，此时的调用关系也变成了简单的面向接口编程了
无法真正的实现：将变化的东西和不变的东西隔离


# 优化
匿名内部类
工厂方法
......